

# 导航规划实践报告

小组成员：**胡天扬	姚利豪	陈季宇**



## 一、路径规划

### $RRT$

#### 优缺点

​	 $RRT$ 的特点之一是 **快**：快速扩张一群像树一样的路径以探索（填充）空间的大部分区域，伺机找到可行的路径。特点之二是 **随机**：虽然像 $Peano$ 曲线这样的单条连续曲线也能探索空间，但是它太**确定**了。如果可行路径不在确定的搜索方向上，那么找到的概率就是0。而如果是随机搜索的话，虽然不知道出路在哪里，但是尝试的次数越多，找到可行路径的概率就越大。

​		而 $RRT$ 的一个弱点是难以在有狭窄通道的环境中找到路径。但是对本项目而言，没有刁钻的障碍物的位置，不会产生狭窄的通道。

#### 实现过程

​		由于已经提供了 $PRM$ 的实现方法，因此按照给出的代码格式进行编程，尽量使用已有接口，但有以下几点需要修改：

1. 采样函数 `sampling()` 中无需进行碰撞检测，而是在 `extend()` 延申节点的过程中检测。

2. $RRT$ 在生成新节点时即可确定当前节点的父节点，因此找到路径后通过回溯父节点就可以找到最终路径，无需像 $PRM$ 在采样结束后进行 `generate roadmap`。

3. 为了体现 $RRT$ 的搜索过程，将可视化过程放入每一次 `extend()` 循环中。

#### 解决问题

1. 在一个循环中，第一次读取 `robot` 的位置信息时为`[-999999, -999999]`，而第二次可以正常读取。考虑到 $UDP$ 建立连接需要时间，猜测是第一次读取时 $UDP$ 尚未通信成功，所以在实例化 `Vision()` 类后给予一定的延时 `time.sleep(0.001)`。

2. 相对于 $PRM$ 来说，$RRT$ 一种动态的规划方式，其 `rrt_tree` 的节点信息随每一次采样都改变，若采用 `KDTree` 的方式搜索最近的节点，会导致时间复杂度和空间复杂度都很大，因此直接通过遍历来寻找最近的节点。

3. 采样点增大时，会出现 $UDP$ 套接字缓冲区大小不够的情况，但是经过计算发现实际 `Debugger()` 传送的字节数并没有超限，询问助教后得知，是由于循环时的信息全部都加入了同一个 `package` 中，因此在每次发送 `Debugger()` 信息前都重新声明 `package`。
4. 当小车附近有障碍物时，会出现死循环的情况，检查发现在 `extend()` 过程中，每次的 `check_obs()` 都返回 `True`，从而导致没有新节点生成。进一步检查发现，原先的碰撞检测逻辑中，第一次检测碰撞是以小车当前的位置信息做判断的，导致了只要最初一定距离内有障碍物，就会判定为发生碰撞。但实际情况可能是，小车背后有障碍，但是与目标点的连线方向并没有障碍，于是对 `check_obs()` 做出改进，在第一次检测周围的障碍物时，先朝目标点移动 $\Delta s$，再进行碰撞判定。

```python
# 在检测碰撞前先step一段距离
x += step_size * np.cos(angle)
y += step_size * np.sin(angle)
# 然后再进行迭代的检测
for i in np.arange(steps):
    distance, index = obs_tree.query(np.array([x, y]))
    if distance <= (self.robot_size + self.avoid_dist):
        return True
```

### $RRT^*$

#### 优缺点

​		在 $RRT$ 中，采样点与整棵树上和它最近的点相连，但这未必是最好的选择，我们的最终目的是让这个点与起点的距离尽可能近，因此可以采用 $RRT^*$ 对此做出改进。但是 $RRT^*$ 相比于 $RRT$ 的缺陷就是慢，所以静态规划中 $RRT^*$ 适用，但动态规划中仍然使用 $RRT$ 进行规划。

#### 实现过程

1. 添加 `rewire()` 重新布线的过程。

#### 解决问题

1. $RRT^*$ 在搜索到路径后并不会停止，而是不断重复 `rewire()` 的过程，直到达到采样上限，所以需要将目标阈值内的可行点信息保存，搜索结束后再从目标可行点的集合中选出一条最优路径（距离最短）。

2. 为提高算法的简洁程度，使用列表 `path` 来存储父节点，这样可以将采样点和父节点的信息结合在一个列表中，即`{node: father node} = {index: path[index]}`，为路径回溯和 `rewire()` 提供便利。

   

## 二、轨迹规划

### 梯形速度规划

#### 原理

​		速度和角速度上均采用梯形速度规划的方法，将轨迹分解为直线和转弯运动组合的叠加，所以可以将问题简化为先做原地转圈，转动到指定方向后做直线运动。此过程需要做两次判断，即转弯到正确方向和到达指定位置的判断。

<img src="报告.assets/image-20211207200236738.png" alt="image-20211207200236738" style="zoom:40%;" />



#### 实现过程

​		对转弯来说，由于发送的命令是一个固定间隔的离散控制信号，转弯的总角度 $\theta$ 不一定能被角速度 $w$ 整除，所以需要做一个约束判断，即给目标角度留出一定的角度裕度 $\theta_m$。同理，直线运动时也要留出距离裕度 $ρ_m$。

​		具体来说，首先令速度 $v$ 加速到指定的最大速度 $v_{max}$，当距离目标小于距离裕度 $ρ_m$ 时，先减速到 $v_{min}$，保证能 **刹住车**，最后减速到 $0$，并执行转弯动作。角速度规划与之同理，即先达到最大角速度 $w_{max}$，达到角度裕度 $\theta_m$ 后减速到 $w_{min}$，最后减速到 $0$。

​		最终调整参数，可以得到 $v_{max}=1000，v_{min}=30，ρ_m=100，w_{max}=2，w_{min}=0.3，\theta_m=0.1$

#### 优缺点

​		这种控制方法思路比较清晰，控制比较简单，但是转弯和直行不能同时进行，而且运动比较死板，不具有**自我调整**的能力。

### 平滑控制 （$Smooth\ Control$）

​		$Smooth\ Control$ 这一算法是由 $JJ\ Park$ 和 $B Kuipers$ 两位学者提出的，主要目的是为了解决差分驱动的机器人如何在二维环境中规划出一条适合其运动的路径，与本题的条件完全相符，因此尝试复现了论文中的算法，论文链接如下：

  [A smooth control law for graceful motion of differential wheeled mobile robots in 2D environment](Park-icra-11.pdf) 

#### 原理

​		这里十分简要地介绍一下其原理。$Smooth\ control$ 以目标姿态构建全局坐标系，设目标点为原点，目标方向为 $x$ 轴，可以计算出与目标距离 $r$，与目标方向夹角 $\delta$，目标方向在全局坐标系的方向角 $\theta$。

<img src="报告.assets/9448293f52f47e59774dc6beaf59c6b.png" alt="9448293f52f47e59774dc6beaf59c6b" style="zoom:50%;" />

​		定义路径曲率 $\kappa(r,\delta,\theta)$，则需要控制的速度 $v$，角速度 $w$，存在以下关系：
$$
w=v\kappa(r,\delta,\theta)\\
\kappa(r,\delta,\theta)=\frac{1}r[k_2(\delta-arctan(-k_1\theta))+(1+\frac{k_1}{1+(k_1\theta)^2}sin\delta)]
$$

​		则只需要选择合适的速度$v$，以及参数$k_1$，$k_2$，就可以控制运动收敛到指定目标

​		在选择速度方法时，可以选择以下方法：
$$
v=\frac{v_{max}}{1+\beta|\kappa(r,\delta,\theta)|^\lambda},\beta>0,\lambda>1
$$
​		于是可以通过调整参数 $\beta,\lambda$ 来确定速度 $v$ 的控制，进而计算出角速度 $w$，实现平滑控制。

​		下面是经过点 `[(1,0),(1,-1),(2,-1),(2,-2),(3,-2)]`的路径和速度及角速度。

<img src="报告.assets/image-20211208225537040.png" alt="image-20211208225537040" style="zoom:40%;" /><img src="报告.assets/image-20211208225613176.png" alt="image-20211208225613176" style="zoom:40%;" />

#### 优缺点		

​		这种方法自身的稳定性非常好，可以说完美符合了机器人的运动学特征，能够规划出一条经过目标点的优美曲线，且完美收敛到目标点。但是它有两个缺陷：其一是在参数调整初期，效果比较差，需要长时间的不断调整来达到比较好的效果。第二个缺陷则是，由于追求极致的曲线，会导致规划出的路径上存在障碍物。

​		而本算法的角速度 $w$ 受到速度 $v$ 的限制，因此没有办法转弯时角速度过慢，需要通过调参解决。同时也实现了论文中的融合版本，但致命的一点是，仿真中有 **加速度的限制**，导致小车容易冲过头，没有办法刹住车，所以总体效果没有 $PID$ 来得好，主要还是参数调节的问题。

#### 效果图

<img src="报告.assets/image-20211208224907256.png" alt="image-20211208224907256" style="zoom:30%;" />

### $PID$ 控制

​		最终我们选定了 $PID$ 控制作为轨迹规划的基本算法，因为其代码实现简单，参数调节容易，且对静态和动态障碍物都有良好的效果。

#### 原理

​		无碰路径是给定的一段折线（红色），小车从一个顶点走向下一个顶点，直到走到终点。最简单的走法是，小车在一个顶点停下，调整好方向，再向下一个点出发，即速度和角速度分开控制。然而这样比较耗时，考虑角速度与线速度并不同时为零的方案较为节省时间，此时不一定严格按照路径行走，但由于这样会导致潜在的碰撞可能，故小车实际路径应当尽可能接近折线。在转弯时，由于小车角速度最大 $5rad/s$ 限制，故随着转弯角度增大线速度必须下降以保证小车不会冲出去离开路径太远。

#### 实现过程

##### 角速度控制

$$
\omega=k_p\Delta\theta_j+k_i\Sigma\Delta\theta+k_d(\Delta\theta_j-\Delta\theta_{j-1})
$$


​		其中，$\omega$ 是输出角速度指令，$\Delta\theta$ 是小车目标朝向角与当前朝向角之差。目标朝向角从小车当前位置指向目标顶点位置，积分项 $\Sigma\Delta\theta$ 和输出 $\omega$ 分别被限幅在一定范围之内：
$$
-5rad/s<\omega<5rad/s\\
-\Sigma\Delta\theta_{\max}<\Sigma\Delta\theta<\Sigma\Delta\theta_{\max}
$$

   调节参数，可得$k_p=10,k_i=0.05,k_d=0,\Sigma\Delta\theta_{\max}=40$​.

##### 线速度控制

​		考虑小车刚刚启动时为了配合方向摆正，线速度应当较慢，之后慢慢上升至最大值，在即将到达时应当适当 **刹车**，但不应降低过多，故引入**偏差项** $v_b$。控制律如下：
$$
v=\max(R(k_pl+k_i\Sigma l+v_b),v_{\max})
$$
其中 $R$ 是一个 **限幅环节**，与角度偏差 $\Delta\theta$ ​​​有关:
$$
R=\max(0,\min(1,k\Delta\theta+b))
$$
其目的是使角度偏差过大时减慢线速度甚至使线速度为0，而在角度偏差较小时为1。在录像中，小车遇到大角度转弯时停下来再慢慢启动，正是受这个 $R$ 控制的。

​		另外，在走到目标顶点之后，需要短暂地向小车发送停车指令以刹车。

​		最后调节参数，可得 $k_p=0.9,k_i=0.015,k_d=0,v_{\max}=1200,v_b=1000,k=\frac{-4}{\pi},b=2$.



## 三、后续优化

### 算法

1. 由于障碍物相对较小，且为了追求更短的时间，将随机采样修改为：一定概率下新的采样点为目标点本身

   ```python
   p = random.random()
   if p < self.prob_goal:
       sample_x, sample_y = goal_x, goal_y
   else:
       sample_x, sample_y = self.sampling()
   ```

2. 为了避免在动态障碍物下小车出现大角度的偏转（这将会增大碰撞概率），我们设定了 **偏差角阈值** 为 $\frac{\pi}{2}$，即小车当前方向和目标方向的差大于这个阈值时，将再次规划路径。
   但存在极端情况是，小车在地图上方且方向朝上，而目标点在下方，此时的偏差角一定会超过阈值，因此再设置采样点数量，即：若连续采样五次都超过阈值，则取消此限制，从而规划出路径。 

   ```python
   for i in np.arange(limit):
       current_ori = vision.my_robot.orientation
       path_x, path_y = planner.plan(vision, vision.my_robot.x, vision.my_robot.y, goal_x, goal_y)
       _, plan_ori = trajectory.find_angle_path(vision.my_robot.x, vision.my_robot.y, 
                                                path_x[0], path_y[0])
       if np.abs(current_ori - plan_ori) < np.pi / 2:
           break
   ```

3. 在动态规划中限制采样点个数的 **下限**，以避免出现绕了很远一条路的情况。

   ```python
   if new_index > self.min_sample:
       return path
   else:
       continue 	#go on sampling
   ```

4. 考虑到动态避障时，采取的策略是：检测到有障碍物挡住路径则重新规划，因此对路径规划的效率要求很高，否则小车会长时间处于失控状态，因此全部使用 `numpy` 库进行存储和运算。主要有

   * 将列表换成 `ndarray` 类型；
   * 将 `math` 库和 `python` 内置的数学运算换成 `numpy` 库进行计算。

5. 对 $RRT^*$ 规划得到的路径进行 **取直** 操作，使得小车转弯次数变小，减少移动时间，类似于 $RRT\_Smart$ 算法。

   ```python
   def make_straight(self, path, path_x, path_y, vision):
       newpath, newpath_x, newpath_y = np.array([[path[0]], [path_x[0]], [path_y[0]]], dtype=int)
       i = 0
       while True:
           for j in np.arange(len(path) - 1, i, -1):
               if not self.check_obs(path_x[i], path_y[i], path_x[j], path_y[j], vision):
                   newpath = np.append(newpath, path[j])
                   newpath_x = np.append(newpath_x, path_x[j])
                   newpath_y = np.append(newpath_y, path_y[j])
                   i = j
                   break      
                   if i == len(path) - 1:
                       break
               return newpath, newpath_x, newpath_y
   ```

6. 将存储障碍物信息 `obs_tree` 获取放在了 `check_obs()` 函数中，这样可以使小车的动态信息获取更为准确，避免了在函数头获取信息、而函数尾才进行碰撞检测所可能产生的误差。

   ```python
   def check_obs(self, ix, iy, nx, ny, vision):
       obstacle_x, obstacle_y = self.find_obs(vision)
       obs_tree = KDTree(np.vstack((obstacle_x, obstacle_y)).T)
   ```

### 代码可读性

1. 将路径规划和轨迹规划的模块各自封装，在 `main` 中实现主循环。
2. 为函数添加 `param`、`return` 等说明。

## 四、一些补充

### 算法

#### 开头碰撞问题

​		之前提到，通过在检测碰撞前先移动一段距离来改进碰撞检测的问题，另外也尝试过在始终碰撞时后退一段指定的距离，再重新规划路径。但是这样意味着要在路径规划的部分插入轨迹规划，编程上不是很方便，而且大大减缓了代码运行效率，增加碰撞的几率，所以没有采取该方案。

#### $UDP$ 通信不稳定

​		网络环境质量不好的时候，$UDP$ 连接容易丢包，导致小车接收不到指令，出现失控的情况。然而不知道该怎么解决这个问题，如果发现小车的速度和角速度突然不改变了，可以去脚本界面看一下有没有实时刷新 `find goal` ，如果没有刷新就说明是 $UDP$ 丢包了。

#### 车卡住

​		有时候会出现小车被障碍物卡死的情况，一般是障碍物挡在小车正前方且小车需要转弯，但是出现这种情况的几率非常非常小（一般是在 $UDP$ 不稳定的情况下），所以没有特定地去解决。

#### 多线程

​		最初路径规划和轨迹规划的融合考虑的是多线程的办法，一个线程持续不断进行轨迹规划，另一个线程负责与仿真软件通信，并间隔地进行路径规划。这样考虑的原因是：轨迹规划的效率一定比路径规划的效率快，如果不使用多线程的话，小车在路径规划的时间内处于失控的状态。

​		但是写完代码发现程序的运行效率反而变低了，于是才想起来 `python` 有 $GIL(Global\ Interpreter\ Lock)$ 锁，导致 `python` 并不能真正执行多线程的功能，不得不放弃多线程。

#### 多进程

​		多线程之后又尝试了多进程，两个进程间通过 $UDP$ 进行通信，实践证明进程间通信的策略有一定效果，在路径规划时应不会影响小车的运行状态，并且可以通过预测小车的位置才抵消路径规划的时滞。但是仍然有一个致命的问题，就是 $UDP$ 通信的不稳定。多进程意味着两个进程都需要与仿真软件进行通信，且两个进程间也要通信，一共用到了三个 $UDP$ 通信，大大增加了丢包的概率。所以最后考虑优化路径规划算法的方式，来解决同时规划的问题。

### 天坑

​		**！！！**千万别用 `numpy.append()` 方法，由于 `numpy` 底层使用 `C语言` 编写的，因此 `ndarray` 就相当于是数组，提前分配好了内存空间，如果添加新元素的话，需要释放原来的内存再分配新的内存，将会大大降低了运行速率。可以通过提前分配一个足够大的数组来解决，但是这个问题在 $DDL$ 前两小时才发现，怕来不及改，就把静态规划中的 $RRT^*$ 版本回退到了使用 `numpy` 前，而动态规划中影响不是很大。

​		另外实践发现 **关闭wifi** 好像可以减少 $UDP$ 的丢包率 (?)，如果实际运行时丢包严重的话可以考虑尝试。

### 注意事项

​	运行 `static_SC` 时，第一次路径有时会生成不了，可能是返回的那个循环丢包了，再次运行就行。

## 五、总结

​		开发的时候我们用到了 $git$ 进行版本控制，所以组内三人没有明确分工，大家有空了就会自行编写代码。我们尝试了很多方法，在路径规划上几乎将 $RRT$ 及其变种都实现了，而我们认为轨迹规划才是难点，只有拥有稳定的轨迹规划后，才能实现不同的路劲规划。因此我们分别尝试了多种轨迹规划的手段，并成功复现了 $Smooth\ control$ 这一算法，但遗憾的是动态情况下效果不佳，所以最后采用了 $RRT+PID$ 的手段。



